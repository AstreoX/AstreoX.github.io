<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git与Github详解：从入门到精通</title>
    <url>/2025/05/12/Git%E4%B8%8EGithub%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    <content><![CDATA[<h1 id="Git-与-GitHub-详解：从入门到精通"><a href="#Git-与-GitHub-详解：从入门到精通" class="headerlink" title="Git 与 GitHub 详解：从入门到精通"></a>Git 与 GitHub 详解：从入门到精通</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>哎呀也是叫我用上“从入门到精通”这个经典标题了，鉴于很多人搞不懂Git和Github的关系，而且也不怎么会使用Git工具，故而写了这篇博客文章，相比于其他介绍Git的文章，我加入了一些类比，希望能达到更好的理解效果。如果还有什么疑问，欢迎在评论区提出！</p>
<p>本篇为入门篇，相对全面地介绍了Git的基本指令用法，后续会有实践篇，我会给出一个Github代码仓库，可供Fork下来进行自己的练习。</p>
<h2 id="一、Git-与-GitHub-的关系"><a href="#一、Git-与-GitHub-的关系" class="headerlink" title="一、Git 与 GitHub 的关系"></a>一、Git 与 GitHub 的关系</h2><p>Git 是一个本地版本控制工具，可以在本地记录文件的修改历史。GitHub 则是一个基于云端的代码托管平台，提供 Git 仓库的存储和协作功能。</p>
<p>两者的关系可以这样理解：</p>
<p><strong>Git 是写作工具</strong></p>
<ul>
<li><p>想象一下 Git 就像是你手头上的笔记软件。当你在写一篇文章（相当于在进行软件开发过程中的代码编写）时，你可以用这个笔记软件随时对文章进行保存（对应 Git 中的提交操作）。每一次保存，你都可以记录下文章在这一刻的具体内容和状态，包括文字的增删改等细节，就像是 Git 能够记录代码的每一次修改细节，知道是谁修改的、什么时候修改的以及修改了哪些地方。</p>
</li>
<li><p>这个笔记软件还允许你创建不同的章节或者子文档（类似于 Git 的分支功能）。比如，你可以在主文档基础上开辟一个专门用于尝试新写作思路的章节，不用担心会影响主文章内容。在软件开发中，开发人员就可以利用 Git 的分支在不影响主代码库的情况下进行新功能的开发或者对现有功能进行优化。</p>
</li>
<li><p>而且，你可以随时回到之前保存的任何版本（这体现了 Git 的版本回溯功能）。如果在写作过程中发现某个修改方向出现了错误，你可以轻松地回到你觉得正确或者满意的那个版本，重新进行编辑。对于代码来说，这就像是在开发过程中遇到 bug 或者不可行的方案时，能够回到之前的稳定版本继续工作。</p>
</li>
</ul>
<p><strong>GitHub 是在线图书馆</strong></p>
<ul>
<li>GitHub 就像是一个大型的在线图书馆。当你完成了自己的文章（代码项目）后，你可以将它 “出版” 到这个图书馆（相当于将代码仓库推送到 GitHub）。这样，世界各地的其他作者（开发者）都可以看到你的文章。他们可以阅读你的文章内容（浏览代码），了解你的写作思路（理解代码功能和架构）。</li>
<li>这个图书馆还提供了一个很好的交流环境。其他作者可以对你文章中的一些观点提出自己的看法（相当于在 GitHub 上进行代码评论和讨论）。他们指出文章的优点或者可能存在的错误，你可以根据这些反馈来改进你的文章（优化代码）。同时，你也可以参考图书馆中其他优秀作者的作品，借鉴他们的写作风格或者结构（学习其他项目的代码架构和算法思想）。</li>
<li>你还可以和他人在图书馆中合作开展一个大型的写作项目（开源项目或者团队开发）。你们可以在图书馆专门开辟一个区域（GitHub 仓库）来共同编辑和整理一本书（进行代码协作），每个人都通过自己的写作工具（Git）对书的内容进行修改和补充，并且将这些修改同步到图书馆（GitHub 仓库）中，让其他合作者也能看到最新的内容变化。</li>
</ul>
<h2 id="二、Git-的安装与配置"><a href="#二、Git-的安装与配置" class="headerlink" title="二、Git 的安装与配置"></a>二、Git 的安装与配置</h2><h3 id="（一）安装-Git"><a href="#（一）安装-Git" class="headerlink" title="（一）安装 Git"></a>（一）安装 Git</h3><ul>
<li><strong>Windows 系统</strong> ：访问<a class="link"   href="https://git-scm.com/" >Git 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，下载适合 Windows 的安装包。运行安装程序，按照安装向导进行操作。在安装过程中，可以选择默认的设置，它会将 Git 添加到系统环境变量中，方便在命令提示符（CMD）或 PowerShell 中使用 Git 命令。</li>
<li><strong>macOS 系统</strong> ：可以通过 Homebrew 包管理工具安装。如果尚未安装 Homebrew，可以在终端中运行 <code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code> 进行安装。安装完成后，在终端中输入 <code>brew install git</code> 命令即可安装 Git。</li>
<li><strong>Linux 系统（以 Ubuntu 为例）</strong> ：打开终端，输入 <code>sudo apt update</code> 命令更新软件包列表。然后输入 <code>sudo apt -y install git</code> 命令来安装 Git。</li>
</ul>
<h3 id="（二）配置-Git-个人信息"><a href="#（二）配置-Git-个人信息" class="headerlink" title="（二）配置 Git 个人信息"></a>（二）配置 Git 个人信息</h3><p>安装完成后，需要配置 Git 的用户名和邮箱，这些信息将用于标识你在 Git 提交中的身份。在终端中运行以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱地址&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;AstreoX&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;Gskyer@outlook.it&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>可以通过以下命令查看配置是否成功：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></div>

<h2 id="三、本地仓库操作"><a href="#三、本地仓库操作" class="headerlink" title="三、本地仓库操作"></a>三、本地仓库操作</h2><h3 id="（一）初始化仓库"><a href="#（一）初始化仓库" class="headerlink" title="（一）初始化仓库"></a>（一）初始化仓库</h3><ul>
<li><strong>创建新仓库</strong> ：首先在本地创建一个项目文件夹，例如 <code>my_project</code>。进入该文件夹，使用 <code>git init</code> 命令将它初始化为一个 Git 仓库。这会在文件夹中创建一个隐藏的 <code>.git</code> 子目录，用于存储版本控制相关的元数据，如提交历史、分支信息等。这就像在空地上打好地基，准备建造一座城堡， initialize 是打地基的过程， <code>.git</code> 目录是地基的一部分，为后续的城堡建设（项目开发）奠定基础。</li>
<li><strong>克隆现有仓库</strong> ：如果需要从远程仓库（如 GitHub 上的仓库）获取代码，可以使用 <code>git clone [repository URL]</code> 命令。例如 <code>git clone https://github.com/user/example - repo.git</code>，这会将远程仓库的全部内容和历史记录复制到本地指定的目录（默认为仓库名称）。这就好比你看到了别人建好的一座漂亮城堡（远程仓库），你想在自己的地盘（本地）也建一座一模一样的，于是你用克隆命令把别人的城堡蓝图和建筑材料（项目代码和历史记录）都搬过来，准备开始建造。</li>
</ul>
<h3 id="（二）文件状态管理"><a href="#（二）文件状态管理" class="headerlink" title="（二）文件状态管理"></a>（二）文件状态管理</h3><ul>
<li><strong>查看文件状态</strong> ：使用 <code>git status</code> 命令可以查看工作目录中文件的状态，包括哪些文件已修改、已暂存或未跟踪等。例如，当你修改了文件 <code>index.html</code> 后，<code>git status</code> 会显示它为已修改状态。这就像是在建筑工地上，你先大致看一下哪些材料已经被切割（文件被修改）、哪些材料已经被搬运到指定位置准备使用（文件被暂存）、哪些材料是新进来的还没决定怎么用（文件未跟踪）。</li>
<li><strong>暂存文件更改</strong> ：如果对文件的修改感到满意，想要将这些修改纳入版本控制，可以使用 <code>git add [file name]</code> 命令将文件的更改暂存到暂存区（Staging Area）。例如 <code>git add index.html</code>。如果要暂存所有修改的文件，可以使用 <code>git add .</code> 命令。暂存区就像是建筑工地上的一个临时材料堆放区，你把打算用到接下来建筑过程中（下次提交）的材料（文件修改）先集中堆放到这里，等准备好一批后一起运到建筑主体（提交到仓库）。</li>
<li><strong>查看暂存区内容</strong> ：通过 <code>git diff --staged</code> 命令可以查看暂存区中文件的更改内容，即即将提交到仓库的更改。这就像是在材料堆放区仔细检查每个材料（文件修改），确认它们是否符合要求，是否就是你准备接下来要用的那些。</li>
</ul>
<h3 id="（三）提交更改"><a href="#（三）提交更改" class="headerlink" title="（三）提交更改"></a>（三）提交更改</h3><ul>
<li><strong>提交暂存区内容</strong> ：使用 <code>git commit -m &quot;[commit message]&quot;</code> 命令将暂存区的内容提交到本地仓库的历史记录中。例如 <code>git commit -m &quot;Add index.html file&quot;</code>。提交信息（commit message）应该简洁明了地描述本次提交的内容和目的。这就像在建筑工地上，当你完成了一部分建筑工作（对文件进行了一系列修改并暂存），你拍照记录下当前的建筑状态（提交暂存区内容），并在照片背面写上简短的说明（commit message），比如 “建好了城堡的第一层墙面”，以便以后查看这张照片时能快速了解当时的工作内容。</li>
<li><strong>跳过暂存区直接提交（不推荐常规使用）</strong> ：如果不想将文件添加到暂存区再提交，可以使用 <code>git commit -a -m &quot;[commit message]&quot;</code> 命令。这会自动将所有已跟踪文件的修改（即之前已经被 Git 管理的文件的更改）提交，但不会添加新的未跟踪文件。这就像是在建筑工地上，不先集中堆放材料（暂存），而是直接把现场所有的旧材料（已跟踪文件）的改动情况都记录下来，这种方式容易遗漏新材料（未跟踪文件），所以不建议经常使用。</li>
<li><strong>查看提交历史</strong> ：运行 <code>git log</code> 命令可以查看本地仓库的提交历史记录，包括提交的哈希值（commit hash）、作者、日期和提交信息等。可以使用 <code>git log --oneline</code> 命令以简洁的单行格式查看提交历史。这就像是翻看建筑工地上的那本记录着每次建筑进度的照片相册（提交历史），每张照片都有唯一的编号（commit hash）、拍摄者（作者）、拍摄日期和简短说明（提交信息），你可以详细查看，也可以用简洁的方式快速浏览每张照片的主要内容（提交的大致情况）。</li>
</ul>
<h2 id="四、远程仓库操作"><a href="#四、远程仓库操作" class="headerlink" title="四、远程仓库操作"></a>四、远程仓库操作</h2><h3 id="（一）添加远程仓库"><a href="#（一）添加远程仓库" class="headerlink" title="（一）添加远程仓库"></a>（一）添加远程仓库</h3><ul>
<li><strong>添加远程仓库地址</strong> ：如果已经有一个本地仓库，并且想要将其与远程仓库关联，可以使用 <code>git remote add [remote name] [repository URL]</code> 命令。通常，<code>remote name</code> 使用默认的 <code>origin</code>。例如 <code>git remote add origin https://github.com/user/my - project.git</code>。这就像是你的城堡（本地仓库）建好后，你告诉快递员（Git）如何把你的城堡介绍资料（项目代码）送到远方的展示中心（远程仓库），你给了快递员展示中心的详细地址（repository URL），并给这个快递路线起了个名字（remote name），方便以后让快递员按这个路线送货。</li>
<li><strong>查看远程仓库信息</strong> ：通过 <code>git remote -v</code> 命令可以查看当前本地仓库关联的所有远程仓库及其 URL 地址。这就像是查看所有设定好的快递路线（关联的远程仓库信息），确认每个路线对应的目的地（仓库 URL）是否正确。</li>
</ul>
<h3 id="（二）推送本地更改到远程仓库"><a href="#（二）推送本地更改到远程仓库" class="headerlink" title="（二）推送本地更改到远程仓库"></a>（二）推送本地更改到远程仓库</h3><ul>
<li><strong>首次推送</strong> ：在确保本地仓库已经提交了所需的更改后，使用 <code>git push -u [remote name] [branch name]</code> 命令将本地更改推送到远程仓库。例如 <code>git push -u origin main</code>（假设分支名称为 main）。这里的 <code>-u</code> 参数会将远程仓库和本地分支关联起来，以后就可以直接使用 <code>git push</code> 命令来推送更改。这就像是第一次通过设定好的快递路线（关联的远程仓库），把你的城堡的新建部分资料（本地提交的更改）送到展示中心（远程仓库），同时用 <code>-u</code> 参数告诉快递员以后沿着这条路线送货时重点关注展示中心的哪个展厅（关联远程仓库和本地分支），以后就不用再特别指明展厅，直接让快递员按之前说好的方式送货（直接用 git push）就行。</li>
<li><strong>后续推送</strong> ：在关联成功后，之后只需要使用 <code>git push</code> 命令就可以将本地分支的更改推送到对应的远程分支。这就像是快递员已经熟悉了送货路线和展厅位置，你只需要说 “送货”，快递员就知道该怎么做了。</li>
</ul>
<h3 id="（三）从远程仓库拉取更改"><a href="#（三）从远程仓库拉取更改" class="headerlink" title="（三）从远程仓库拉取更改"></a>（三）从远程仓库拉取更改</h3><ul>
<li><strong>拉取远程更改</strong> ：如果远程仓库有新的更改，想要更新本地仓库，可以使用 <code>git pull [remote name] [branch name]</code> 命令。例如 <code>git pull origin main</code>。这会自动将远程仓库的更改合并到本地当前分支中。这就像是展示中心（远程仓库）的城堡资料（项目代码）更新了，你通知快递员（Git）把最新的资料（远程更改）取回来，并自动整合到你本地的城堡资料（本地分支）中，方便你查看和继续开发。</li>
<li><strong>只获取远程信息但不合并（先进一步查看）</strong> ：使用 <code>git fetch [remote name]</code> 命令可以从远程仓库获取最新的分支信息等，但不会自动合并更改。然后可以通过 <code>git log</code> 命令查看远程分支和本地分支的差异等，再决定是否进行合并。这就像是先让快递员把展示中心的最新城堡资料目录（远程分支信息）拿回来，你自己先看看目录（用 git log 查看差异），决定是否要让快递员把具体资料（更改内容）也取回来并整合到本地资料中。</li>
</ul>
<h2 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h2><h3 id="（一）创建分支"><a href="#（一）创建分支" class="headerlink" title="（一）创建分支"></a>（一）创建分支</h3><ul>
<li><strong>创建新分支</strong> ：使用 <code>git branch [branch name]</code> 命令可以创建一个新的分支。例如 <code>git branch feature - branch</code> 创建一个名为 feature - branch 的新分支。此时，工作目录的内容仍然是当前分支（如 main 分支）的状态。这就像是在建城堡的过程中，你从主城堡区域（main 分支）开辟出一块新的空地（新分支），打算在这里尝试建设一个新功能区域（比如一个花园，对应 feature - branch 分支），但此时你还没有转到这块新空地去干活，主城堡区域还是原来的样子。</li>
<li><strong>切换分支</strong> ：要切换到新创建的分支，可以使用 <code>git checkout [branch name]</code> 命令。例如 <code>git checkout feature - branch</code>。切换后，工作目录中的文件会变为新分支对应的状态。这就像是你放下手头主城堡区域（原分支）的活儿，转到新开辟的花园区域（新分支）开始建设，工作环境（工作目录文件）就变成了花园区域的初始状态。</li>
<li><strong>简化创建并切换分支的操作</strong> ：可以使用 <code>git checkout -b [branch name]</code> 命令一步完成创建并切换到新分支的操作，如 <code>git checkout -b bug - fix</code>。这就像是你直接说 “我要在城堡边开辟个新区域专门修个消防设施（bug - fix 分支）并马上去那干活”，这个命令一次性完成了开辟新区域（创建分支）和转到那干活（切换分支）的操作。</li>
</ul>
<h3 id="（二）查看分支"><a href="#（二）查看分支" class="headerlink" title="（二）查看分支"></a>（二）查看分支</h3><ul>
<li><strong>查看本地分支</strong> ：运行 <code>git branch</code> 命令可以查看本地所有的分支列表。当前所在的分支前会有一个星号（*）标识。这就像是查看城堡四周所有已开辟的区域（本地分支）的列表，当前你正在干活的那个区域（当前分支）前面会插着个小旗子（星号标识）。</li>
<li><strong>查看远程分支</strong> ：使用 <code>git branch -r</code> 命令可以查看远程仓库的分支列表。这就像是查看展示中心（远程仓库）里各个展厅（远程分支）的目录，看看里面都存放着哪些版本的城堡资料。</li>
<li><strong>查看所有分支（包括本地和远程）</strong> ：通过 <code>git branch -a</code> 命令可以查看本地和远程的所有分支。这就像是同时查看自己城堡周边的所有区域（本地分支）和展示中心的展厅目录（远程分支），全面了解所有分支情况。</li>
</ul>
<h3 id="（三）合并分支"><a href="#（三）合并分支" class="headerlink" title="（三）合并分支"></a>（三）合并分支</h3><ul>
<li><strong>合并分支到当前分支</strong> ：假设当前在 main 分支，想要合并 feature - branch 分支的更改，可以使用 <code>git merge [branch name]</code> 命令，即 <code>git merge feature - branch</code>。Git 会根据两个分支的提交历史找到共同的祖先提交，然后合并更改。如果在合并过程中出现冲突，Git 会提示你解决冲突。这就像是你建好了花园区域（feature - branch 分支）的新功能，现在想把这部分建设成果整合到主城堡区域（main 分支）。Git 会查看花园建设和主城堡建设的历史记录，找到它们最初分叉（共同祖先提交）的地方，然后把花园的新建设内容整合到主城堡区域。如果在这个过程中，比如花园和主城堡都对同一块地的用途有不同规划（合并冲突），Git 就会提醒你过来协调，决定到底这块地该怎么用。</li>
<li><strong>解决冲突</strong> ：当合并出现冲突时，Git 会在冲突的文件中标记冲突的内容。你需要手动编辑这些文件，解决冲突的部分（例如，保留正确的代码逻辑）。解决完冲突后，使用 <code>git add [conflicted file]</code> 命令将修改后的文件标记为已解决冲突，然后再使用 <code>git commit</code> 命令完成合并提交。这就像是你亲自来到那块有争议的地，把花园和主城堡对该地的不同规划进行协调，确定最终的用途，修改好规划图（解决冲突文件内容），然后告诉施工人员（git add）这块地的规划已经确定了，最后记录下这次规划整合的操作（git commit）。</li>
</ul>
<h3 id="（四）删除分支"><a href="#（四）删除分支" class="headerlink" title="（四）删除分支"></a>（四）删除分支</h3><ul>
<li><strong>删除本地分支</strong> ：使用 <code>git branch -d [branch name]</code> 命令可以删除本地分支。例如 <code>git branch -d feature - branch</code>。如果分支尚未合并，Git 默认不允许删除，除非你使用 <code>-D</code> 参数强制删除（不推荐轻易使用，因为可能会丢失更改）。这就像是你要拆除城堡周边的一个区域（本地分支），如果这个区域有些建设内容还没整合到主城堡（未合并分支），Git 默认会阻止你，因为这样可能会丢失那些有价值的建设成果。除非你用 <code>-D</code> 参数强制拆除（不推荐，容易造成损失），不然还是先整合好再拆除更稳妥。</li>
<li><strong>删除远程分支</strong> ：要删除远程分支，可以使用 <code>git push [remote name] --delete [branch name]</code> 命令。例如 <code>git push origin --delete bug - fix</code>。这就像是通知快递员把展示中心里的某个展厅（远程分支）拆除，以后这个展厅里的资料就不存在了，团队成员再也看不到这个分支的内容了。</li>
</ul>
<h2 id="六、标签管理"><a href="#六、标签管理" class="headerlink" title="六、标签管理"></a>六、标签管理</h2><h3 id="（一）创建标签"><a href="#（一）创建标签" class="headerlink" title="（一）创建标签"></a>（一）创建标签</h3><ul>
<li><strong>轻量级标签</strong> ：使用 <code>git tag [tag name]</code> 命令可以创建一个轻量级标签。例如 <code>git tag v1.0</code>。轻量级标签就像一个指向特定提交的指针，不包含额外的信息。这就像是你在城堡的一张重要照片（某个关键提交）背面简单地写了个编号（tag name），方便以后快速找到这张照片，但没有写其他说明内容。</li>
<li><strong>附注标签（推荐）</strong> ：使用 <code>git tag -a [tag name] -m &quot;[tag message]&quot;</code> 命令可以创建附注标签。例如 <code>git tag -a v1.0.1 -m &quot;Release version 1.0.1&quot;</code>。附注标签会包含标签信息，如标签名、日期、消息等，更适合用于标记重要的版本发布。这就像是你在那张重要照片（特定提交）后面不仅写了编号（tag name），还详细记录了拍摄日期（日期）、照片里的建筑内容说明（tag message）等丰富信息，这样以后查看时能更全面地了解这个版本的背景和重要性。</li>
</ul>
<h3 id="（二）查看标签"><a href="#（二）查看标签" class="headerlink" title="（二）查看标签"></a>（二）查看标签</h3><ul>
<li><strong>查看所有标签</strong> ：运行 <code>git tag</code> 命令可以查看本地仓库中的所有标签。这就像是查看一个相册（本地仓库标签），里面存放着所有带编号和说明的照片（标签），你可以快速浏览有哪些版本被标记过。</li>
<li><strong>查看标签详细信息</strong> ：对于附注标签，可以使用 <code>git show [tag name]</code> 命令查看标签的详细信息，包括提交信息、标签消息等内容。这就像是打开某张详细标记过的照片，不仅能看到照片本身（提交基本信息），还能看到背后写的日期、说明等所有详细内容（标签详细信息）。</li>
</ul>
<h3 id="（三）推送和拉取标签"><a href="#（三）推送和拉取标签" class="headerlink" title="（三）推送和拉取标签"></a>（三）推送和拉取标签</h3><ul>
<li><strong>推送标签到远程仓库</strong> ：使用 <code>git push [remote name] [tag name]</code> 命令可以将单个标签推送到远程仓库。例如 <code>git push origin v1.0</code>。如果要推送所有标签，可以使用 <code>git push origin --tags</code> 命令。这就像是把本地相册里的某一张照片（单个标签）或者全部照片（所有标签）都拿去展示中心（远程仓库）进行展示，方便团队成员或者其他人查看这些重要版本的标记。</li>
<li><strong>从远程仓库拉取标签</strong> ：可以使用 <code>git fetch --tags</code> 命令从远程仓库获取所有的标签。如果只获取特定标签，可以使用 <code>git fetch [remote name] [tag name]</code> 命令。这就像是从展示中心（远程仓库）把所有的或者特定的标签照片（标签）都取回本地相册（本地仓库），方便自己查看这些版本标记。</li>
</ul>
<h2 id="七、撤销修改与恢复"><a href="#七、撤销修改与恢复" class="headerlink" title="七、撤销修改与恢复"></a>七、撤销修改与恢复</h2><h3 id="（一）撤销工作目录中的修改"><a href="#（一）撤销工作目录中的修改" class="headerlink" title="（一）撤销工作目录中的修改"></a>（一）撤销工作目录中的修改</h3><ul>
<li><strong>撤销单个文件的修改</strong> ：如果只是想丢弃工作目录中某个文件的修改，可以使用 <code>git checkout -- [file name]</code> 命令。例如 <code>git checkout -- index.html</code>。这会将文件恢复到上次暂存或提交时的状态。这就像是在建筑工地上，你对某块砖（文件）刚做的修改（比如涂了颜料）不满意，你想恢复它之前没涂颜料（上次暂存或提交时）的样子，于是你用这个命令把颜料擦掉，让砖回到之前的状态。</li>
<li><strong>撤销所有文件的修改</strong> ：使用 <code>git checkout -- .</code> 命令可以撤销工作目录中所有文件的修改，将工作目录恢复到与上次暂存或提交一致的状态。这就像是整个建筑工地现场（工作目录）刚有些混乱，砖啊、木板啊都被随意涂画（文件被修改），你不想保留这些修改，于是用这个命令把所有材料都恢复到上次整理好（暂存或提交时）的样子，工地又变得整洁规范了。</li>
</ul>
<h3 id="（二）从暂存区撤销修改"><a href="#（二）从暂存区撤销修改" class="headerlink" title="（二）从暂存区撤销修改"></a>（二）从暂存区撤销修改</h3><ul>
<li><strong>从暂存区移除单个文件</strong> ：如果想要将某个已经暂存的文件从暂存区移除，但保留工作目录中的修改，可以使用 <code>git reset [file name]</code> 命令。例如 <code>git reset index.html</code>。这样文件又回到未暂存的已修改状态。这就像是你把一堆准备用于接下来建筑（暂存区的文件）的材料（文件）中的某一块砖（单个文件）从建筑用料区（暂存区）挪开，但它还在工地上（工作目录修改保留），你可能还想对这块砖进一步加工修改后再利用。</li>
<li><strong>从暂存区移除所有文件</strong> ：使用 <code>git reset</code> 命令可以将暂存区中的所有文件移除，但不会改变工作目录中的文件内容，文件仍然处于已修改状态。这就像是你把所有原本计划用于接下来建筑施工（暂存区文件）的材料（文件）都从建筑用料区（暂存区）挪开，但它们都还放在工地上（工作目录修改保留），你可以重新评估这些材料是否要用，或者怎么用。</li>
</ul>
<h3 id="（三）回退提交"><a href="#（三）回退提交" class="headerlink" title="（三）回退提交"></a>（三）回退提交</h3><ul>
<li><strong>回退到指定提交（并丢弃后续提交）</strong> ：使用 <code>git reset --hard [commit hash]</code> 命令可以将当前分支的 HEAD 指针回退到指定的提交哈希值对应的提交，并且会丢弃该提交之后的所有提交更改。这是一个非常危险的操作，因为会丢失后续的提交数据。例如 <code>git reset --hard 6e207c9</code>（假设 6e207c9 是要回退到的提交哈希值的前几位）。这就像是你发现城堡建到某一层（指定提交）后，后续的建设出现了严重问题，你决定直接拆除这一层以后的所有建筑（丢弃后续提交），回到那一层的状态（回退到指定提交）。但这个操作不可逆，拆除的部分就没了，所以很危险，要谨慎使用。</li>
<li><strong>回退到指定提交（保留后续提交作为未暂存的修改）</strong> ：使用 <code>git reset [commit hash]</code> 命令（不加 <code>--hard</code> 参数）回退到指定提交时，会保留该提交之后的更改作为未暂存的修改。这就像是你沿着城堡的楼梯（提交历史）往下走，回到某一层（指定提交），但你把后续楼层（后续提交）的建筑材料（文件修改内容）都搬下来，堆放在这一层（保留为未暂存的修改），你可以根据需要决定是重新利用这些材料，还是丢弃它们。</li>
</ul>
<h2 id="八、Git-与-GitHub-协作"><a href="#八、Git-与-GitHub-协作" class="headerlink" title="八、Git 与 GitHub 协作"></a>八、Git 与 GitHub 协作</h2><h3 id="（一）在-GitHub-上创建仓库"><a href="#（一）在-GitHub-上创建仓库" class="headerlink" title="（一）在 GitHub 上创建仓库"></a>（一）在 GitHub 上创建仓库</h3><ol>
<li>登录 GitHub 官网（<a class="link"   href="https://github.com/" >https://github.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）。</li>
<li>点击右上角的 “+” 号，选择 “New repository” 选项。</li>
<li>在 “Repository name” 中输入仓库名称，可以添加可选的描述信息。</li>
<li>选择仓库的访问权限（公开或私有）。</li>
<li>可以选择是否初始化仓库（例如添加一个 README 文件），然后点击 “Create repository” 按钮。这就像是在展示中心（GitHub 平台）里申请一块新的展区（创建仓库），你给这个展区起了名字（Repository name），写了个简介（描述信息），设定好是公开让所有观众参观（公开仓库）还是只让特定的人参观（私有仓库），还可以先放个简单的说明牌（README 文件），最后确认完成展区的建立。</li>
</ol>
<h3 id="（二）将本地仓库与-GitHub-仓库关联"><a href="#（二）将本地仓库与-GitHub-仓库关联" class="headerlink" title="（二）将本地仓库与 GitHub 仓库关联"></a>（二）将本地仓库与 GitHub 仓库关联</h3><ol>
<li>在本地仓库中，使用 <code>git remote add origin [repository URL]</code> 命令添加远程仓库地址。例如 <code>git remote add origin https://github.com/user/my - project.git</code>。这就像是把本地的城堡（本地仓库）和展示中心的展区（GitHub 仓库）用一条专用道路（关联）连接起来，告诉城堡里的人（Git）展区的具体位置（repository URL），方便以后运输资料（代码）。</li>
<li>可以使用 <code>git remote -v</code> 命令查看远程仓库是否关联成功。这就像是检查这条专用道路（远程仓库关联）是否真的修建好，是否可以正常使用。</li>
</ol>
<h3 id="（三）协作工作流程"><a href="#（三）协作工作流程" class="headerlink" title="（三）协作工作流程"></a>（三）协作工作流程</h3><ul>
<li><p><strong>Fork 与 Pull Request（适用于开源项目贡献）</strong></p>
<ul>
<li><strong>Fork 仓库</strong> ：如果想要为一个开源项目贡献代码，而你没有直接写入权限，可以点击项目仓库页面上的 “Fork” 按钮，将仓库复制到自己的 GitHub 账号下。这就像是看到展示中心有个很受欢迎的城堡模型（开源项目仓库），你特别想参与完善它，但你没有直接在原模型上修改的权限。于是你用 Fork 按钮在自己的展区（自己 GitHub 账号下）复制了一份这个城堡模型，准备在自己的地盘上进行改进。</li>
<li><strong>克隆 Fork 后的仓库到本地</strong> ：使用 <code>git clone [forked repository URL]</code> 命令将 Fork 后的仓库克隆到本地。这就像是把复制到自己展区的城堡模型资料（Fork 后的仓库）再下载到自己的工作室（本地），方便你实际动手修改完善。</li>
<li><strong>在本地进行更改和提交</strong> ：创建新分支（如 <code>feature - branch</code>），进行代码修改，提交更改到本地分支。这就像是在工作室里，你针对城堡模型的新功能（feature - branch 分支）进行建造和修改，定期记录下自己的工作成果（提交修改）。</li>
<li><strong>推送到自己的 Fork 仓库</strong> ：使用 <code>git push origin feature - branch</code> 命令将本地分支推送到自己 Fork 后的仓库。这就像是把自己的改进后的城堡模型部分（本地分支更改）通过物流（git push）运送到自己展区的仓库里进行展示，方便别人查看你的成果。</li>
<li><strong>创建 Pull Request</strong> ：在自己 Fork 后的仓库页面，点击 “New pull request” 按钮。选择要合并的分支（通常是自己的特性分支和原项目的主分支，如 main 或 master），填写 Pull Request 的标题和描述，说明自己的更改内容和目的，然后提交 Pull Request。原项目的维护者会收到通知，对 Pull Request 进行审查、讨论和可能的合并。这就像是你向原城堡模型的作者（开源项目维护者）发去一个邀请函（Pull Request），详细说明你做的改进（标题和描述），请他们来你的展区参观这部分改进，并询问是否可以把你的改进整合到他们的原模型中（请求合并到原项目的主分支）。</li>
</ul>
</li>
<li><p><strong>团队协作（使用远程仓库）</strong></p>
<ul>
<li><strong>克隆团队仓库到本地</strong> ：团队成员使用 <code>git clone [team repository URL]</code> 命令克隆团队的远程仓库到本地。这就像是团队每个成员都从团队共享的城堡设计资料库（团队远程仓库）里把资料下载到自己的工作室（本地），准备开始自己的建设任务。</li>
<li><strong>在本地创建分支并开发</strong> ：每个成员在本地创建自己的分支（如 <code>dev - member1</code>），进行开发工作，在自己的分支上提交更改。这就像是每个团队成员在自己的工作室里，针对城堡的不同部分（自己的分支）进行建设工作，定期记录自己的工作进展（提交修改）。</li>
<li><strong>定期同步远程仓库更改</strong> ：为了保持本地仓库与团队仓库的同步，成员可以使用 <code>git pull origin main</code>（假设主分支是 main）来拉取远程仓库的最新更改，合并到自己的分支（可能需要解决冲突）。这就像是团队成员定期去团队共享资料库（远程仓库）查看有没有其他成员更新的城堡设计内容（最新的改动），如果有，就把这些更新整合到自己正在建设的部分（合并到自己的分支），保证自己的工作和团队整体工作不脱节，如果整合过程中发现和其他成员的工作有冲突（比如都修改了同一块区域的设计），就一起协商解决。</li>
<li><strong>完成功能并提交到远程仓库</strong> ：当成员完成自己负责的功能开发后，使用 <code>git push origin [branch name]</code> 命令将代码推送到远程仓库的对应分支。然后可以通过团队协作平台（如 GitHub 的 Pull Request 功能）来发起代码审查等流程，决定是否将该分支的代码合并到主分支。这就像是团队成员完成了自己负责的城堡部分建设工作（功能开发），把成果（分支代码）上传到团队共享资料库（远程仓库对应分支），然后通过团队协作流程（Pull Request 等）让其他成员和负责人审查自己的建设成果，决定是否把这部分成果整合到整个城堡的主体结构中（合并到主分支）。</li>
</ul>
</li>
</ul>
<p>希望这篇详细的 Git 与 GitHub 指南对你有所帮助，让你在代码管理的道路上更加得心应手！</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to My Blog</title>
    <url>/2024/10/04/hello-blog/</url>
    <content><![CDATA[<h2 id="大家好，我是-Gskyer！"><a href="#大家好，我是-Gskyer！" class="headerlink" title="大家好，我是 Gskyer！"></a>大家好，我是 Gskyer！</h2><p>欢迎来到我的个人博客！</p>
<h3 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h3><p>在这个博客中，你将找到一些技术主题的分享，包括编程技巧、项目经验以及我的个人见解。我希望这些内容能对你有所帮助。</p>
<h3 id="新访客指南"><a href="#新访客指南" class="headerlink" title="新访客指南"></a>新访客指南</h3><ul>
<li><strong>浏览博客</strong>：你可以通过菜单栏浏览各类文章，或者使用搜索功能寻找特定主题。</li>
<li><strong>评论</strong>：如果你对我的文章有任何想法或问题，欢迎在下方留言。这个博客使用 Giscus 评论系统，你可以轻松地参与讨论。</li>
</ul>
<h3 id="Giscus-评论系统使用指南"><a href="#Giscus-评论系统使用指南" class="headerlink" title="Giscus 评论系统使用指南"></a>Giscus 评论系统使用指南</h3><p>Giscus 是基于 GitHub Discussions 的评论系统，它允许访客使用 GitHub 账号进行评论。以下是如何使用 Giscus 的步骤：</p>
<ol>
<li><p><strong>登录 GitHub</strong>：</p>
<ul>
<li>要发表评论，你需要先登录你的 GitHub 账号。</li>
<li>点击评论区的”使用 GitHub 登录”按钮进行授权。</li>
</ul>
</li>
<li><p><strong>发表评论</strong>：</p>
<ul>
<li>登录后，你可以在评论框中输入你的评论内容。</li>
<li>Giscus 支持完整的 Markdown 语法，你可以添加格式、链接、图片等。</li>
<li>点击”评论”按钮提交你的评论。</li>
</ul>
</li>
<li><p><strong>查看和回复评论</strong>：</p>
<ul>
<li>所有评论将显示在文章下方的评论区。</li>
<li>要回复某个评论，点击该评论下方的”回复”按钮。</li>
</ul>
</li>
<li><p><strong>互动功能</strong>：</p>
<ul>
<li>你可以对评论点赞、添加表情反应。</li>
<li>所有评论和互动都会同步到对应的 GitHub Discussions 主题中。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>所有评论都是公开的，且会在 GitHub 上永久保存。</li>
<li>请遵守社区规范，尊重他人，避免发布不当内容。</li>
<li>如果你想编辑或删除自己的评论，可以直接在 GitHub Discussions 中进行操作。</li>
</ul>
</li>
</ol>
<h3 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h3><p>我想特别感谢 Hexo 框架和 Redefine 主题，提供了如此优秀的工具，使我能够轻松创建和管理我的博客。</p>
<p>感谢你的光临，期待与你们的交流！</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>Welcome</tag>
        <tag>self-introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>Git与Github详解：实践篇</title>
    <url>/2025/05/13/Git%E4%B8%8EGithub%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%AE%9E%E8%B7%B5%E7%AF%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇文章中，我们详细了解了 Git 的基本概念、工作流和常用命令。在本文中，我们将通过一个实际的项目案例，来逐步演示如何在 GitHub 上进行代码托管和协作。</p>
<p>本次演示仓库以我和国科大的好哥们共同开发的c语言围棋游戏为演示仓库 <a class="link"   href="https://github.com/AstreoX/CGo" >AstreoX&#x2F;CGo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，其中的 <code>ai.c</code> 演示了一个基于蒙特卡洛树搜索（MCTS）的决策示例。本文将引导你从 <strong>安装配置</strong>、<strong>命令行操作</strong> 到 <strong>VS Code 可视化</strong>，一步步学会如何：</p>
<ol>
<li>Fork &amp; Clone</li>
<li>创建分支 &amp; 修改参数</li>
<li>本地 Commit &amp; Push</li>
<li>发起 Pull Request</li>
<li>参与代码审阅与合并</li>
</ol>
<hr>
<h2 id="安装与初始配置"><a href="#安装与初始配置" class="headerlink" title="安装与初始配置"></a>安装与初始配置</h2><h3 id="1-安装-Git"><a href="#1-安装-Git" class="headerlink" title="1. 安装 Git"></a>1. 安装 Git</h3><ul>
<li><p><strong>Windows</strong>、<strong>macOS</strong>、<strong>Linux</strong> 均可从官网下载安装包：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://git-scm.com/download/</span><br></pre></td></tr></table></figure></div>

<p><strong>上一篇文章已有详细说明，这里不再赘述。</strong></p>
</li>
<li><p>安装完成后，在终端（Windows PowerShell &#x2F; macOS Terminal &#x2F; Linux Shell）输入：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></div>

<p>应看到类似 <code>git version 2.x.x</code> 的输出。</p>
</li>
</ul>
<h3 id="2-全局配置"><a href="#2-全局配置" class="headerlink" title="2. 全局配置"></a>2. 全局配置</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>这两个信息会出现在每次提交记录中。</p>
</blockquote>
<h3 id="3-注册-GitHub-账号"><a href="#3-注册-GitHub-账号" class="headerlink" title="3. 注册 GitHub 账号"></a>3. 注册 GitHub 账号</h3><ol>
<li>打开 <a class="link"   href="https://github.com/" >https://github.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 并注册。</li>
<li>完成邮箱验证。</li>
<li>（强烈建议）在 <strong>Settings → SSH and GPG keys</strong> 添加你的 SSH 公钥，以便后续无需每次输入密码：<ul>
<li>首先我们在空白处右键，在右键菜单的更多选项中选择“Open Git Bash Here”<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="1.png"
                      alt="打开Git Bash"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="2.png"
                      alt="Git Bash窗口界面示例"
                ></li>
<li>然后输入以下命令（邮箱记得替换成你自己的，注意不要有空格，然后一路无脑回车即可）：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;you@example.com&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>然后将生成的私钥添加到ssh-agent中：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">ssh-add ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure></div></li>
<li>接着Git Bash中输入下面命令：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure></div></li>
<li>然后将显示的公钥内容复制到剪贴板</li>
<li>然后打开GitHub，在右上角的头像菜单中选择“Settings”<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="3.png"
                      alt="打开Settings"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="4.png"
                      alt="打开Settings"
                ></li>
<li>然后在左侧菜单中选择 “SSH and GPG keys”<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="5.png"
                      alt="选择SSH and GPG keys"
                ></li>
<li>然后点击“New SSH key”</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="6.png"
                      alt="点击New SSH key"
                ></li>
<li>Title 随便取一个，将刚刚复制的公钥内容粘贴到 Key 中，然后点击“Add SSH key”</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="7.png"
                      alt="添加SSH key"
                ></li>
<li>然后点击“Add SSH key”</li>
<li>至此，我们的SSH公钥就添加成功了</li>
<li>最后，我们可以测试一下是否成功：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></div></li>
<li>然后输入“yes”，如果显示“Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.”，则说明成功了</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Fork-Clone-仓库"><a href="#Fork-Clone-仓库" class="headerlink" title="Fork &amp; Clone 仓库"></a>Fork &amp; Clone 仓库</h2><p>无论命令行还是 VS Code，可视化，第一步都是 <strong>Fork</strong> 一份到自己账号并拉到本地。</p>
<ol>
<li><p>访问我的仓库：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/AstreoX/CGo</span><br></pre></td></tr></table></figure></div></li>
<li><p>点击右上角 <strong>Fork</strong>，将仓库复制到 <code>yourname/CGo</code>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="8.png"
                      alt="点击Fork"
                ></p>
</li>
<li><p>再进入到你Fork的仓库，点击 <strong>Code</strong>，复制仓库地址。<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="9.png"
                      alt="点击Code"
                ></p>
</li>
<li><p>在你本地的电脑上，创建一个合适的文件夹来作为项目目录（建议路径要为全英文），然后老样子右键点击空白处，选择“Open Git Bash Here”<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="1.png"
                      alt="打开Git Bash"
                ></p>
</li>
<li><p>接着输入<code>git clone</code>空格之后，将你刚刚复制的仓库地址粘贴进去，然后回车即可<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="10.png"
                      alt="输入git clone"
                ></p>
</li>
<li><p>此时，Git就会开始在本地克隆远程仓库的内容到你指定的目录中。</p>
</li>
</ol>
<p>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="11.png"
                      alt="输入cd CGo"
                ></p>
<ol start="7">
<li>然后，你就可以在本地看到克隆的仓库代码了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="12.png"
                      alt="克隆完成"
                ></li>
</ol>
<hr>
<h2 id="传统命令行工作流"><a href="#传统命令行工作流" class="headerlink" title="传统命令行工作流"></a>传统命令行工作流</h2><h3 id="初始化仓库-添加上游"><a href="#初始化仓库-添加上游" class="headerlink" title="初始化仓库 &amp; 添加上游"></a>初始化仓库 &amp; 添加上游</h3><p>Git Bash窗口不要关掉，接着输入以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> CGo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加上游指向原仓库（便于后续同步主分支）</span></span><br><span class="line">git remote add upstream https://github.com/AstreoX/CGo.git</span><br><span class="line">git remote -v</span><br><span class="line"><span class="comment"># 应看到 origin（你的仓库）和 upstream（原仓库）</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="13.png"
                      alt="添加上游"
                ></p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ol>
<li>查看当前分支：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></div></li>
<li>创建并切换分支：<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b tune-mcts</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="14.png"
                      alt="创建并切换分支"
                ></p>
<h3 id="修改-提交"><a href="#修改-提交" class="headerlink" title="修改 &amp; 提交"></a>修改 &amp; 提交</h3><ol>
<li><p>用你喜欢的编辑器打开 <code>src/ai.c</code>，在程序的第19-23行找到：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="15.png"
                      alt="修改参数"
                ><br>根据注释调整MCTS的搜索参数，做出一些修改</p>
</li>
<li><p>保存后回到命令行：<br>使用以下命令查看文件状态：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="16.png"
                      alt="查看文件状态"
                ><br>会看到src&#x2F;ai.c被标记为修改</p>
<p>然后使用以下命令将修改添加到暂存区：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git add src/ai.c</span><br><span class="line">git diff --staged   <span class="comment"># 查看暂存区对比，能看到你改动了代码的哪些地方</span></span><br><span class="line">git commit -m <span class="string">&quot;在这里记录你修改的参数，例如：Tune MCTS: sim=2000, exploration=1.20&quot;</span></span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="17.png"
                      alt="提交修改"
                ></p>
</li>
</ol>
<h3 id="推送-发起-Pull-Request"><a href="#推送-发起-Pull-Request" class="headerlink" title="推送 &amp; 发起 Pull Request"></a>推送 &amp; 发起 Pull Request</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推送到你远程仓库</span></span><br><span class="line">git push -u origin tune-mcts</span><br></pre></td></tr></table></figure></div>
<h2 id="之后访问-https-github-com-yourname-CGo-页面会提示-“Compare-pull-request”，说明你已经成功推送了分支，需要发起-Pull-Request。-点击-“Create-pull-request”，填写标题和描述，然后点击-“Create-pull-request”。-然后就会跳转到Pull-Request页面，你可以在这里查看你的改动、发起评论、参与讨论等。-这里显示没有代码冲突，直接点击-“Merge-pull-request”-即可。-然后点击-“Confirm-merge”-即可完成合并。-然后就可以看到你的改动已经被合并到主分支了。"><a href="#之后访问-https-github-com-yourname-CGo-页面会提示-“Compare-pull-request”，说明你已经成功推送了分支，需要发起-Pull-Request。-点击-“Create-pull-request”，填写标题和描述，然后点击-“Create-pull-request”。-然后就会跳转到Pull-Request页面，你可以在这里查看你的改动、发起评论、参与讨论等。-这里显示没有代码冲突，直接点击-“Merge-pull-request”-即可。-然后点击-“Confirm-merge”-即可完成合并。-然后就可以看到你的改动已经被合并到主分支了。" class="headerlink" title="- 之后访问 https://github.com/yourname/CGo- 页面会提示 “Compare &amp; pull request”，说明你已经成功推送了分支，需要发起 Pull Request。  - 点击 “Create pull request”，填写标题和描述，然后点击 “Create pull request”。- 然后就会跳转到Pull Request页面，你可以在这里查看你的改动、发起评论、参与讨论等。- 这里显示没有代码冲突，直接点击 “Merge pull request” 即可。- 然后点击 “Confirm merge” 即可完成合并。- 然后就可以看到你的改动已经被合并到主分支了。
  "></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="18.png"
                      alt="推送到远程仓库"
                ><br>- 之后访问 <a class="link"   href="https://github.com/yourname/CGo" >https://github.com/yourname/CGo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>- 页面会提示 “Compare &amp; pull request”，说明你已经成功推送了分支，需要发起 Pull Request。<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="19.png"
                      alt="发起Pull Request"
                ><br>- 点击 “Create pull request”，填写标题和描述，然后点击 “Create pull request”。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20.png"
                      alt="填写标题和描述"
                ><br>- 然后就会跳转到Pull Request页面，你可以在这里查看你的改动、发起评论、参与讨论等。<br>- 这里显示没有代码冲突，直接点击 “Merge pull request” 即可。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="21.png"
                      alt="Merge pull request"
                ><br>- 然后点击 “Confirm merge” 即可完成合并。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="22.png"
                      alt="Confirm merge"
                ><br>- 然后就可以看到你的改动已经被合并到主分支了。
  </h2><h2 id="VS-Code-可视化工作流"><a href="#VS-Code-可视化工作流" class="headerlink" title="VS Code 可视化工作流"></a>VS Code 可视化工作流</h2><p>在刚刚克隆到本地的代码仓库，右键选择“Open with Code”，或者直接在VS Code中打开该文件夹，就可以开始可视化操作了。</p>
<h3 id="安装必备扩展"><a href="#安装必备扩展" class="headerlink" title="安装必备扩展"></a>安装必备扩展</h3><ol>
<li><strong>GitLens — Git supercharged</strong>：增强代码注释与历史浏览。</li>
<li><strong>GitHub Pull Requests and Issues</strong>：在 VS Code 中直接浏览&#x2F;发起 PR。</li>
</ol>
<h3 id="分支与改动管理"><a href="#分支与改动管理" class="headerlink" title="分支与改动管理"></a>分支与改动管理</h3><ul>
<li><p><strong>切换&#x2F;创建分支</strong>：</p>
<ul>
<li>点击下方加号 → “Create new branch” → 输入 <code>tune-mcts-2</code> → 按回车创建<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="24.png"
                      alt="创建分支"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="25.png"
                      alt="创建分支"
                ><br>这里会出现三个选项，我们只需要关心前两个，分别是单纯的创建分支、创建分支并切换到该分支。</li>
</ul>
<p>根据自己的喜好选择即可（一般情况下，我们选择创建分支并切换到该分支）</p>
</li>
<li><p><strong>查看改动</strong>：</p>
<ul>
<li>在 <strong>源代码管理</strong> 面板能看到所有未暂存与已暂存的文件</li>
<li>点击文件名可打开 diff 视图</li>
</ul>
</li>
</ul>
<h3 id="修改-提交-1"><a href="#修改-提交-1" class="headerlink" title="修改 &amp; 提交"></a>修改 &amp; 提交</h3><ol>
<li><p>在资源管理器中打开 <code>src/ai.c</code>，修改参数并保存。</p>
</li>
<li><p>在 <strong>源代码管理</strong> 面板：</p>
<ul>
<li><p>将 <code>ai.c</code> 拖动到 “Staged Changes”</p>
</li>
<li><p>在上方输入提交信息：</p>
<blockquote>
<p>Tune MCTS: sim&#x3D;2000, exploration&#x3D;1.20</p>
</blockquote>
</li>
<li><p>点击 ✓ 提交</p>
</li>
</ul>
</li>
</ol>
<h3 id="推送-发起-PR"><a href="#推送-发起-PR" class="headerlink" title="推送 &amp; 发起 PR"></a>推送 &amp; 发起 PR</h3><ul>
<li><p><strong>推送</strong>：顶部会出现 “Publish Branch” 按钮，点击即可。</p>
</li>
<li><p><strong>发起 PR</strong>：</p>
<ul>
<li>安装 “GitHub Pull Requests and Issues” 后，点击左侧 “GitHub” 图标</li>
<li>选择 “Create Pull Request” → 目标库选择 <code>AstreoX/CGo</code> → 填写标题和描述 → 提交</li>
</ul>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上 <strong>命令行 + VS Code 可视化</strong> 的方式进行版本控制，我们可以更方便地管理代码，并与他人协作。在实际开发中，我们可以根据需要灵活选择适合自己的版本控制方式，以提高开发效率。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法入门解析</title>
    <url>/2025/05/10/Markdown-%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Markdown-语法入门解析"><a href="#Markdown-语法入门解析" class="headerlink" title="Markdown 语法入门解析"></a>Markdown 语法入门解析</h1><p>在数字写作的世界里，Markdown 是一种简单而强大的轻量级标记语言。它允许人们使用易读易写的纯文本格式编写文档，像是这种个人博客就需要以markdown的语法来编辑。这篇文章将带你入门 Markdown 的核心语法，让你轻松掌握这种高效的写作语法。</p>
<h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>标题在 Markdown 中使用 <code>#</code> 号来创建。<code>#</code> 的数量决定了标题的级别，从 <code>#</code>（一级标题）到 <code>######</code>（六级标题）。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure></div>

<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="二、段落与换行"><a href="#二、段落与换行" class="headerlink" title="二、段落与换行"></a>二、段落与换行</h2><p>一个或多个连续的文本行组成一个段落，段落之间用一个或多个空行分隔。若要强制换行，需在行末尾加两个空格（软换行）或者使用双反斜杠（\）（硬换行）。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个段落。它由多行文本组成，</span><br><span class="line">但没有空行分隔，所以 Markdown 会将其视为一个单独的段落呈现。</span><br><span class="line"></span><br><span class="line">这是另一个段落。由于与上一段之间有空行分隔，所以会被渲染为独立的段落。</span><br></pre></td></tr></table></figure></div>

<p>这是一个段落。它由多行文本组成，<br>但没有空行分隔，所以 Markdown 会将其视为一个单独的段落呈现。</p>
<p>这是另一个段落。由于与上一段之间有空行分隔，所以会被渲染为独立的段落。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">这是强制换行的示例，  </span><br><span class="line">行末尾加两个空格可以实现换行。</span><br></pre></td></tr></table></figure></div>

<p>这是强制换行的示例，<br>行末尾加两个空格可以实现换行。</p>
<h2 id="三、文本样式"><a href="#三、文本样式" class="headerlink" title="三、文本样式"></a>三、文本样式</h2><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p>使用双星号 <code>**</code> 或双下划线 <code>__</code> 包裹文本，可使文本显示为粗体。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**这是粗体文本**</span></span><br></pre></td></tr></table></figure></div>

<p><strong>这是粗体文本</strong></p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>使用单星号 <code>*</code> 或单下划线 <code>_</code> 包裹文本，可使文本显示为斜体。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*这是斜体文本*</span></span><br></pre></td></tr></table></figure></div>

<p><em>这是斜体文本</em></p>
<h2 id="四、列表"><a href="#四、列表" class="headerlink" title="四、列表"></a>四、列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用星号 <code>*</code>、加号 <code>+</code> 或减号 <code>-</code> 创建无序列表项。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br></pre></td></tr></table></figure></div>

<ul>
<li>第一项</li>
</ul>
<ul>
<li>第二项</li>
</ul>
<ul>
<li>第三项</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用数字后跟英文点号创建有序列表项。数字的实际值无关紧要，渲染时会自动编号。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">3.</span> 第三项</span><br></pre></td></tr></table></figure></div>

<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h2 id="五、链接"><a href="#五、链接" class="headerlink" title="五、链接"></a>五、链接</h2><p>Markdown 支持两种创建链接的方式：行内式和参考式。</p>
<h3 id="行内式链接"><a href="#行内式链接" class="headerlink" title="行内式链接"></a>行内式链接</h3><p>将链接文本放在方括号 <code>[ ]</code> 中，链接地址放在圆括号 <code>( )</code> 中。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://www.baidu.com</span>)</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://www.baidu.com/" >百度<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="参考式链接"><a href="#参考式链接" class="headerlink" title="参考式链接"></a>参考式链接</h3><p>为链接定义一个标签，在方括号 <code>[ ]</code> 中写入链接文本，在方括号后紧跟一个由方括号和尖括号组成的标签引用。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>][<span class="symbol">1</span>]</span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://www.baidu.com</span></span><br></pre></td></tr></table></figure></div>

<p>[百度][1]</p>
<h2 id="六、图片"><a href="#六、图片" class="headerlink" title="六、图片"></a>六、图片</h2><p>图片的语法类似于链接，在链接语法基础上加一个感叹号 <code>!</code>。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">描述文本</span>](<span class="link">https://free4.yunpng.top/2025/05/10/681f5d422db19.png</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://free4.yunpng.top/2025/05/10/681f5d422db19.png"
                      alt="描述文本"
                ></p>
<h2 id="七、代码"><a href="#七、代码" class="headerlink" title="七、代码"></a>七、代码</h2><p>在 Markdown 中，可以使用反引号 <code>`</code> 包裹代码片段。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`var x = 5;`</span></span><br></pre></td></tr></table></figure></div>

<p><code>var x = 5;</code></p>
<p>对于多行代码块，可以使用缩进法（每行缩进 4 个空格或 1 个制表符），或者使用围栏式代码块（使用三个反引号 <code>```</code> 包裹代码块，并可指定编程语言）。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 缩进法</span><br><span class="line">function test() &#123;</span><br><span class="line">    console.log(&#x27;Hello World&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<pre><code>// 缩进法
function test() &#123;
    console.log(&#39;Hello World&#39;);
&#125;
</code></pre>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 围栏式代码块</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 围栏式代码块</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="八、引言"><a href="#八、引言" class="headerlink" title="八、引言"></a>八、引言</h2><p>使用大于号 <code>&gt;</code> 来创建引言。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个引言。</span></span><br><span class="line"><span class="quote">&gt; 可以包含多行文本。</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>这是一个引言。<br>可以包含多行文本。</p>
</blockquote>
<h2 id="九、水平线"><a href="#九、水平线" class="headerlink" title="九、水平线"></a>九、水平线</h2><p>使用三个或更多星号 <code>*</code>、减号 <code>-</code> 或下划线 <code>_</code> 创建水平线。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"><span class="strong">***</span></span></span><br><span class="line"><span class="strong"><span class="section">---</span></span></span><br><span class="line"><span class="strong"><span class="section">__<span class="emphasis">_</span></span></span></span><br></pre></td></tr></table></figure></div>

<hr>
<hr>
<hr>
<h2 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h2><p>创建表格需要使用竖线 <code>|</code> 分隔表格单元格，使用连字符 <code>-</code> 创建表头分隔栏。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">| 表头 1 | 表头 2 | 表头 3 |</span><br><span class="line">|--------|--------|--------|</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>表头 1</th>
<th>表头 2</th>
<th>表头 3</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<h2 id="十一、强调（注释）"><a href="#十一、强调（注释）" class="headerlink" title="十一、强调（注释）"></a>十一、强调（注释）</h2><p>Markdown 支持使用双感叹号 <code>!!</code> 等符号来实现强调效果，但这种强调效果可能因渲染引擎的不同而有所差异。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">!!注意!!：这是一个需要特别注意的地方。</span><br></pre></td></tr></table></figure></div>

<p>!!注意!!：这是一个需要特别注意的地方。</p>
<h2 id="十二、其他语法"><a href="#十二、其他语法" class="headerlink" title="十二、其他语法"></a>十二、其他语法</h2><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>使用双波浪线 <code>~~</code> 包裹文本，可使文本显示为删除线。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">~~这是一段被删除的文本~~</span><br></pre></td></tr></table></figure></div>

<p><del>这是一段被删除的文本</del></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>Markdown 支持脚注，使用方括号 <code>[ ]</code> 和 caret 符号 <code>^</code> 创建脚注。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">这是正文文本[^1]。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">（示例）这是脚注内容。</span></span><br></pre></td></tr></table></figure></div>

<p>这是正文文本<a href="%EF%BC%88%E7%A4%BA%E4%BE%8B%EF%BC%89%E8%BF%99%E6%98%AF%E8%84%9A%E6%B3%A8%E5%86%85%E5%AE%B9%E3%80%82">^1</a>。</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>使用反斜杠 <code>\</code> 可以对特殊字符进行转义。</p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">\* 这是一个星号，不是列表符号。</span><br></pre></td></tr></table></figure></div>

<p>* 这是一个星号，不是列表符号。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这就是markdown的入门解析，希望这篇文章能帮助你快速上手 Markdown。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>教程</tag>
        <tag>语法</tag>
        <tag>学习</tag>
        <tag>Markdown</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>大语言模型P1</title>
    <url>/2025/02/07/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8BP1/</url>
    <content><![CDATA[<h2 id="北京大语言模型实践-Day-1"><a href="#北京大语言模型实践-Day-1" class="headerlink" title="北京大语言模型实践 Day 1"></a>北京大语言模型实践 Day 1</h2><p>​ 来到北京第一天，参加大语言模型的实践。</p>
<p>​ 今天北京真的是格外的冷，零下 19 度，还有大风呼呼地吹，本来带了两件外套想着轮着穿，结果到最后一起穿在了身上，裹的和太空人一样</p>
<hr>
<h3 id="课程资源介绍"><a href="#课程资源介绍" class="headerlink" title="课程资源介绍"></a>课程资源介绍</h3><p>我们的课程资源大概有这三个方面：</p>
<h4 id="1-《Hands-On-Large-Language-Models》"><a href="#1-《Hands-On-Large-Language-Models》" class="headerlink" title="1. 《Hands-On Large Language Models》"></a>1. <strong>《Hands-On Large Language Models》</strong></h4><p>这书倒是蛮新的，新到国内尚无中文译本（截至我们开课前 2025.2.7）</p>
<p>而且手把手教着搓大语言模型，实践性很强，有配套的 Github 代码仓库</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/rasbt/LLMs-from-scratch</span><br></pre></td></tr></table></figure></div>

<h4 id="2-《大语言模型》（赵鑫-李军毅-周昆-唐天一-文继荣-著）"><a href="#2-《大语言模型》（赵鑫-李军毅-周昆-唐天一-文继荣-著）" class="headerlink" title="2. 《大语言模型》（赵鑫&#x2F;李军毅&#x2F;周昆&#x2F;唐天一&#x2F;文继荣 著）"></a>2. <strong>《大语言模型》</strong>（赵鑫&#x2F;李军毅&#x2F;周昆&#x2F;唐天一&#x2F;文继荣 著）</h4><p>这书感觉就是更加理论化一点，而且因为是国内大佬编写的，所以也不像第一个英文原版一样读起来还有点困难，作为实践之中的理论补充还是非常不错的</p>
<h4 id="3-OpenBMB"><a href="#3-OpenBMB" class="headerlink" title="3. OpenBMB"></a>3. <strong>OpenBMB</strong></h4><p>这是个携手清华打造的线上课程，分 p 很细，可以挑选自己感兴趣的着重学习一下，虽然这个主要是我们在实践前作为前置内容学习的，不过课程还是非常有质量有深度的，回来还是要再好好看一下</p>
<hr>
<p>ok，那么接下来进入课程</p>
<p>开课的惯例：课程介绍，老师介绍，大语言模型趋势，人工智能与机器学习的基本概念介绍</p>
<p>一大堆介绍之后，心心念念的大语言模型闪亮登场。这也算是我最感兴趣的内容，从了解到大语言模型之日起（大概是在 22 年 11 月份刚刚使用过 GPT 后不久），我就一直非常好奇这种 LLM 究竟是怎样理解我们人类的语言的。之前只是模模糊糊知道一点关于“token”的事情，知道那是个大概的大模型拆分语言的单元，今天算是能从头到尾去彻底了解一下了</p>
<p>（另外下面小小的感慨一下）</p>
<p>PPT 正文首页就是“60 年的算法积累，辛顿位列 C 位，能在 60 年前人类的 CPU 才刚刚迈入集成电路的时代的算力条件下有勇气去搞神经网络，“先驱”一词在他身上大概就是最好的体现。 （另外，对于辛顿有一篇文章写的特别好，可以来看看 链接：<a class="link"   href="https://www.zhihu.com/question/493793998/answer/1901401663572538161" >为什么有些人能够那么强大又那么温柔？ - 知乎<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508014658701.png"
                     
                ></p>
<hr>
<p>好了言归正传，让我们首先来从大语言模型的历史开始：</p>
<h3 id="自然语言处理引子"><a href="#自然语言处理引子" class="headerlink" title="自然语言处理引子"></a>自然语言处理引子</h3><p><strong>在 2017 年划时代的 Transformer 架构发布之前，众多优秀的计算机科学家也在自然语言处理的道路上进行了深远的探索。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508014809451.png"
                     
                ></p>
<h4 id="1-词袋模型-（Bag-of-Words）"><a href="#1-词袋模型-（Bag-of-Words）" class="headerlink" title="1. 词袋模型 （Bag-of-Words）"></a>1. 词袋模型 （Bag-of-Words）</h4><h5 id="主要前提"><a href="#主要前提" class="headerlink" title="主要前提"></a>主要前提</h5><p>​ 假设文本的语义主要由其中包含的词汇及其出现次数决定，而词的顺序和语法可以忽略。</p>
<h5 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h5><ul>
<li>首先需要从训练文本中提取所有不同的单词，形成一个词典</li>
</ul>
<p>​ 再对于每一文本，根据词典中单词的出现次数，将文本转换为一个向量</p>
<ul>
<li><p>有点抽象不太好懂？</p>
<p>举个例子：</p>
<p>假设有两句话：“我爱自然语言处理”和“自然语言处理很有趣”。</p>
<p>构建词典时，会将所有不同的词列出：[“我”, “爱”, “自然语言处理”, “很”, “有趣”]。</p>
<p>第一句话对应的向量就是 1,1,1,0,0，第二句话对应的向量是 0,0,1,1,1。</p>
<p>词袋模型的处理就是这个样子，有点类似于关键词匹配</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508014907527.png"
                     
                ></p>
<h5 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h5><p>这样子好处当然是有的，<strong>处理算法的简单带来了计算的高效</strong></p>
<p>但是缺点也显而易见：</p>
<ul>
<li><strong>丢失语序信息</strong>：词袋模型忽略了词的顺序，这可能导致对文本语义的误解，比如 “我喜欢她”和“她喜欢我”在词袋模型中表示相同，但这实际上就根本不是一回事</li>
<li><strong>维度灾难</strong>：当文本数据量大时，词典的维度可能会变得非常高，导致向量维度过大，增加计算复杂度。</li>
<li><strong>无法捕捉语义</strong>：无法捕捉词之间的语义关系和上下文信息，不同的词即使语义相似，在词袋模型中也会被表示为不同的维度。</li>
</ul>
</li>
</ul>
<h4 id="2-Word2Vec-（稠密向量-嵌入向量）"><a href="#2-Word2Vec-（稠密向量-嵌入向量）" class="headerlink" title="2.Word2Vec （稠密向量&#x2F;嵌入向量）"></a>2.Word2Vec （稠密向量&#x2F;嵌入向量）</h4><p>​ 这我觉得是一项天才般的技术设计，巧妙地使程序具有了类似人类的语义理解功能，让我们一起来看一下：</p>
<ul>
<li><h5 id="主要假设"><a href="#主要假设" class="headerlink" title="主要假设"></a>主要假设</h5></li>
</ul>
<p>​ 分布式语义假说（”You shall know a word by the company it keeps”）</p>
<p>​ 也就是说，它信奉<strong>词的出现上下文决定词的语义</strong>假说，将每个词看成一个点，通过训练，让频繁一起出现的词在向量空间中距离更近，从而捕捉词的语义信息。</p>
<ul>
<li><h5 id="我们举一个二维空间的例子来理解"><a href="#我们举一个二维空间的例子来理解" class="headerlink" title="我们举一个二维空间的例子来理解"></a>我们举一个二维空间的例子来理解</h5></li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508014943467.png"
                     
                ></p>
<p>如图所示我们可以看到有 cats dog apple building adult 等单词分布在这个空间中 其中 cats dog puppy 都是小宠物一类的，在这个向量空间中就非常接近，聚成了一簇；同时我们观察另外几个类似的簇，都能找到类似的共同点</p>
<p>那么，通过查找在向量空间中的距离远近，大语言模型就可以理解其中不同词的相关性，做出一种语义的理解。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508015024925.png"
                     
                ></p>
</li>
<li><p>想想看，我们人类的词典也是用一些词去解释另一个词，直到一些基本的词不能再拆分为显式的解释，而是一种模模糊糊的次级概念。对于大模型也是一样 word2vec 技术也并没有具体的把每个簇都显式地加上一个标签对吧，也是大模型的一种模模糊糊的<strong>次级概念理解</strong>。</p>
</li>
<li><p>那么在自然语言的处理过程中，将语言中的词去映射为低维，稠密的向量的过程，就叫做向量嵌入，也就是常说的 embedding 过程。</p>
</li>
<li><p>而且不仅是单词，实际上，<strong>不同层级的文本都可以做 embedding</strong>，token 层级，word 层级，sentence 层级，document 层级上都可以做向量嵌入，单词的 embedding 就是单词的一个向量表示它的语义，句子的 embedding 就是这句话的语义向量（当然可能这句话的语义很复杂，但确实是可以的），文档的 embedding 就是这一大段的一个整体的语义。</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508015051118.png"
                     
                ></p>
</li>
<li><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li><strong>一词多义问题：</strong> 像是 charge 这样有很多很不想干的释义就难以在向量空间中找到合适的对应位置</li>
<li><strong>缺少上下文信息</strong>：如像是 it 这种代词，单论语义很复杂，什么都有可能包含，需要去看上下文信息解读所代指的东西，但如果纯靠向量来解析语义就很困难</li>
</ul>
</li>
</ul>
<h4 id="3-RNN（Recurrent-Neural-Network）"><a href="#3-RNN（Recurrent-Neural-Network）" class="headerlink" title="3. RNN（Recurrent Neural Network）"></a>3. RNN（Recurrent Neural Network）</h4><p>​ 那么为了解决上下文信息的问题，人们又引入了这玩意儿——<strong>循环神经网络</strong></p>
<ul>
<li><p>RNN 具有<strong>记忆功能</strong>，它会对之前的信息进行记忆，将信息从当前步骤传递到下一步骤，形成一个<strong>循环结构</strong>，使得网络能够记住之前的信息，对于序列数据的处理非常有效。</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508015117355.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508015129267.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508015208156.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="20250508015218774.png"
                     
                ></p>
</li>
<li><p>(上图展示的为带注意力机制的 RNN)</p>
</li>
<li><p>但是我们从他的运行方式就可以看到，它是一种<strong>循环顺序运行</strong>的方式，每次只处理一个附加的 token，这种方式<strong>无法并行计算</strong>，就无法使其运行速度得到很大的提高。</p>
<p>而且这种序列化的处理方式也对训练带来了很多困难。如果训练的序列过长，就会有<strong>梯度消失</strong>或者<strong>梯度爆炸</strong>，难以捕捉长序列中的上下文关系。</p>
</li>
</ul>
<hr>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>​ 好了，<strong>Bag-of-Words</strong>带我们迈入了自然语言处理的大门，<strong>Word2Vec</strong>技术又通过巧妙的向量语义空间设置，使自然语言处理在语义理解方面甩开了大步子，<strong>RNN</strong>试图解决上下文的注意力问题，但方向似乎有点不对头，无法并行计算到最后终究只能靠大力出奇迹，不过也走得很远啦，在一般的情感分析和机器翻译任务中也取得了不少傲人的成绩。</p>
<p>​ <strong>一切都已就位，似乎就差那么关键的一步了……</strong></p>
<p>​ RNN 的无法并行计算特点极大地限制了算力的释放，针对长上下文的处理也并没有达到很好的效果，这成为了卡住大规模自然语言处理的最后一道枷锁。</p>
<p>​ 舞台已经搭建好，演员已经全部就位，那划时代的架构即将登场了……</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>AI</category>
        <category>大语言模型</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>教程</tag>
        <tag>AI</tag>
        <tag>大语言模型</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Windows环境下nodejieba安装问题</title>
    <url>/2025/05/08/%E8%A7%A3%E5%86%B3Windows%E7%8E%AF%E5%A2%83%E4%B8%8Bnodejieba%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在使用Hexo博客系统的过程中，当主题需要使用中文分词功能时，常常会依赖<code>nodejieba</code>这个Node.js模块。(主要为了做文章推荐) <code>nodejieba</code>是”结巴”中文分词的Node.js实现，由底层C++库提供支持，提供高效的中文分词功能。然而，在Windows环境下安装<code>nodejieba</code>时，常常会遇到各种编译错误，特别是在使用较新版本的Node.js时。（是的已红温）</p>
<p>本文将详细记录我在Windows环境下遇到的<code>nodejieba</code>安装问题，以及借助AI与nodejieba斗智斗勇的过程——如何通过创建兼容层来解决这个问题，使Hexo博客能够正常工作。</p>
<h2 id="错误现象"><a href="#错误现象" class="headerlink" title="错误现象"></a>错误现象</h2><p>在尝试使用<code>npm install nodejieba@latest</code>命令安装最新版本的<code>nodejieba</code>时，出现了以下编译错误：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm error code 1</span><br><span class="line">npm error path D:\code\hexo\blog\node_modules\nodejieba</span><br><span class="line">npm error command failed</span><br><span class="line">npm error command C:\Windows\system32\cmd.exe /d /s /c node-pre-gyp install --fallback-to-build</span><br><span class="line">npm error D:\code\hexo\blog\node_modules\nodejieba\submodules\cppjieba\include\cppjieba\Trie.hpp(1,1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失</span><br></pre></td></tr></table></figure></div>

<p>错误信息非常长，主要是C++代码编译过程中遇到了很多语法错误和编码问题。关键错误包括：</p>
<ol>
<li>字符编码问题：文件包含不能在当前代码页(936)中表示的字符</li>
<li>C++代码语法错误：大量的”未声明的标识符”、”语法错误”等</li>
<li>预编译二进制下载失败：<code>getaddrinfo ENOTFOUND 7897</code></li>
</ol>
<p>这些错误导致<code>nodejieba</code>无法在Windows环境下成功安装和编译，进而导致Hexo生成站点时报错：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Cannot find module &#x27;nodejieba&#x27;</span><br><span class="line">Require stack:</span><br><span class="line">- D:\code\hexo\blog\themes\redefine\scripts\helpers\recommendation-helpers.js</span><br></pre></td></tr></table></figure></div>

<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>经过聪明的Claude 3.7 Sonnet师傅的指点迷津，我决定采用以下策略来解决这个问题：</p>
<ol>
<li>找到一个与<code>nodejieba</code>功能相似但对Windows更友好的替代库</li>
<li>创建一个兼容层，使替代库能够以<code>nodejieba</code>的API形式被使用</li>
<li>将这个兼容层安装为本地模块，使Node.js能够找到它</li>
</ol>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="步骤1：寻找替代库"><a href="#步骤1：寻找替代库" class="headerlink" title="步骤1：寻找替代库"></a>步骤1：寻找替代库</h3><p>通过网络搜索，我发现<code>@node-rs/jieba</code>是一个不错的替代选择。这是一个基于Rust实现的中文分词库，编译为WebAssembly，对跨平台有更好的支持，特别是在Windows环境下。</p>
<p>首先，安装<code>@node-rs/jieba</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @node-rs/jieba</span><br></pre></td></tr></table></figure></div>

<p>安装过程很顺利，没有出现编译错误。</p>
<h3 id="步骤2：了解API差异"><a href="#步骤2：了解API差异" class="headerlink" title="步骤2：了解API差异"></a>步骤2：了解API差异</h3><p>接下来，需要了解原始<code>nodejieba</code>和<code>@node-rs/jieba</code>之间的API差异。为此，我找AI创建了一系列测试脚本。</p>
<p>首先，检查<code>@node-rs/jieba</code>导出了哪些内容：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jieba = <span class="built_in">require</span>(<span class="string">&#x27;@node-rs/jieba&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Available methods and properties:&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(jieba));</span><br></pre></td></tr></table></figure></div>

<p>输出结果表明<code>@node-rs/jieba</code>导出了两个主要类：<code>Jieba</code>和<code>TfIdf</code>：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Available methods and properties:</span><br><span class="line">[ &#x27;Jieba&#x27;, &#x27;TfIdf&#x27; ]</span><br></pre></td></tr></table></figure></div>

<p>然后，我尝试使用这些类来进行分词：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Jieba</span>, <span class="title class_">TfIdf</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@node-rs/jieba&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个jieba分词实例</span></span><br><span class="line"><span class="keyword">const</span> jieba = <span class="keyword">new</span> <span class="title class_">Jieba</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试分词</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Cut result:&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jieba.<span class="title function_">cut</span>(<span class="string">&#x27;南京市长江大桥&#x27;</span>, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cut result:</span><br><span class="line">[ &#x27;南京市&#x27;, &#x27;长江大桥&#x27; ]</span><br></pre></td></tr></table></figure></div>

<p>通过测试，我确认了<code>@node-rs/jieba</code>提供的API与原始<code>nodejieba</code>有很大不同（所以为什么有这么大不同但名字还要这么相似呢？）：</p>
<ol>
<li><code>@node-rs/jieba</code>导出类需要实例化，而不是直接提供函数</li>
<li>方法名称基本相同，但使用方式不同</li>
<li><code>TfIdf</code>类有<code>extractKeywords</code>方法，但在我们的测试中无法正常工作</li>
</ol>
<h3 id="步骤3：创建兼容层"><a href="#步骤3：创建兼容层" class="headerlink" title="步骤3：创建兼容层"></a>步骤3：创建兼容层</h3><p>基于对两个库API的理解，再次发动AI创建了一个兼容层<code>nodejieba.js</code>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容层，使@node-rs/jieba能被Hexo主题识别为nodejieba</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Jieba</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@node-rs/jieba&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">const</span> jiebaInstance = <span class="keyword">new</span> <span class="title class_">Jieba</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出与nodejieba相同的API</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 基本分词函数</span></span><br><span class="line">  <span class="attr">cut</span>: <span class="function">(<span class="params">text, hmm = <span class="literal">true</span></span>) =&gt;</span> jiebaInstance.<span class="title function_">cut</span>(text, hmm),</span><br><span class="line">  <span class="attr">cutAll</span>: <span class="function">(<span class="params">text</span>) =&gt;</span> jiebaInstance.<span class="title function_">cut</span>(text, <span class="literal">true</span>),</span><br><span class="line">  <span class="attr">cutForSearch</span>: <span class="function">(<span class="params">text, hmm = <span class="literal">true</span></span>) =&gt;</span> jiebaInstance.<span class="title function_">cutForSearch</span>(text, hmm),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 词性标注</span></span><br><span class="line">  <span class="attr">tag</span>: <span class="function">(<span class="params">text</span>) =&gt;</span> jiebaInstance.<span class="title function_">tag</span>(text),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关键词抽取 - 简化为返回空数组，避免报错</span></span><br><span class="line">  <span class="attr">extract</span>: <span class="function">(<span class="params">text, topN = <span class="number">5</span></span>) =&gt;</span> [],</span><br><span class="line">  <span class="attr">textRankExtract</span>: <span class="function">(<span class="params">text, topN = <span class="number">5</span></span>) =&gt;</span> [],</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 空实现，避免报错</span></span><br><span class="line">  <span class="attr">load</span>: <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 默认词典路径（实际上@node-rs/jieba内置词典）</span></span><br><span class="line">  <span class="attr">DEFAULT_DICT</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">DEFAULT_HMM_DICT</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">DEFAULT_IDF_DICT</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">DEFAULT_STOP_WORD_DICT</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这个兼容层主要做了以下工作：</p>
<ol>
<li>实例化一个<code>Jieba</code>对象</li>
<li>导出与原始<code>nodejieba</code>相同的函数接口</li>
<li>将这些函数实现为对<code>Jieba</code>实例方法的调用</li>
<li>对于无法直接实现的功能，如<code>extract</code>和<code>textRankExtract</code>，简化为返回空数组</li>
<li>添加原始<code>nodejieba</code>特有的词典路径常量</li>
</ol>
<h3 id="步骤4：测试兼容层"><a href="#步骤4：测试兼容层" class="headerlink" title="步骤4：测试兼容层"></a>步骤4：测试兼容层</h3><p>创建<code>test-nodejieba.js</code>来测试我们的兼容层：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试我们的nodejieba兼容层</span></span><br><span class="line"><span class="keyword">const</span> nodejieba = <span class="built_in">require</span>(<span class="string">&#x27;./nodejieba&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Cut result:&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cutResult = nodejieba.<span class="title function_">cut</span>(<span class="string">&#x27;南京市长江大桥&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Type:&#x27;</span>, <span class="keyword">typeof</span> cutResult, <span class="title class_">Array</span>.<span class="title function_">isArray</span>(cutResult));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cutResult);</span><br></pre></td></tr></table></figure></div>

<p>测试结果表明我们的兼容层能够正确分词，并返回预期的结果：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cut result:</span><br><span class="line">Type: object true</span><br><span class="line">[ &#x27;南京市&#x27;, &#x27;长江大桥&#x27; ]</span><br></pre></td></tr></table></figure></div>

<h3 id="步骤5：创建本地模块"><a href="#步骤5：创建本地模块" class="headerlink" title="步骤5：创建本地模块"></a>步骤5：创建本地模块</h3><p>虽然我们的兼容层能够正常工作，但Node.js在进行<code>require(&#39;nodejieba&#39;)</code>时仍然找不到这个模块。为了解决这个问题，我们需要将兼容层安装为本地模块。</p>
<p>首先，在<code>node_modules</code>目录下创建<code>nodejieba</code>文件夹：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p node_modules/nodejieba</span><br></pre></td></tr></table></figure></div>

<p>然后创建<code>package.json</code>文件：</p>
<div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nodejieba&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3.4.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Compatible layer for nodejieba using @node-rs/jieba&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MIT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@node-rs/jieba&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>将我们的兼容层代码保存为模块的主文件<code>index.js</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> nodejieba.js node_modules/nodejieba/index.js</span><br></pre></td></tr></table></figure></div>

<p>最后，使用<code>npm link</code>命令使模块在系统中可见：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> node_modules/nodejieba</span><br><span class="line">npm <span class="built_in">link</span></span><br><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure></div>

<h3 id="步骤6：验证解决方案"><a href="#步骤6：验证解决方案" class="headerlink" title="步骤6：验证解决方案"></a>步骤6：验证解决方案</h3><p>再次运行<code>node -e &quot;const nodejieba = require(&#39;nodejieba&#39;); console.log(nodejieba.cut(&#39;南京市长江大桥&#39;));&quot;</code>命令，确认模块可以正常导入和使用。</p>
<p>最后，运行<code>hexo g</code>命令生成博客站点，成功解决了问题：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) PS D:\code\hexo\blog&gt; hexo g</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 143 ms</span><br><span class="line">INFO  Generated: 404.html</span><br><span class="line">...</span><br><span class="line">INFO  21 files generated in 92 ms</span><br></pre></td></tr></table></figure></div>

<h2 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h2><p>主要策略是使用基于Rust的<code>@node-rs/jieba</code>替代原始的C++实现，并通过创建兼容层让系统能够继续使用原有的API。</p>
<p>这种方法的优点是：</p>
<ol>
<li>避开了C++编译环境配置的复杂性</li>
<li>利用了Rust&#x2F;WebAssembly更好的跨平台性能</li>
<li>不需要修改依赖<code>nodejieba</code>的原始代码</li>
</ol>
<p>同时也有一些限制：</p>
<ol>
<li>关键词提取功能（<code>extract</code>和<code>textRankExtract</code>）被简化为返回空数组</li>
<li>词性标注可能与原始实现有细微差别</li>
<li>需要手动安装和维护本地模块</li>
</ol>
<h3 id="后续优化方向"><a href="#后续优化方向" class="headerlink" title="后续优化方向"></a>后续优化方向</h3><p>如果有需要，可以进一步（找AI）完善这个兼容层：</p>
<ol>
<li>尝试实现关键词提取功能，可能需要自己编写相关算法或找到其他替代库</li>
<li>将兼容层发布为npm包，方便其他遇到该问题的倒霉蛋使用</li>
<li>创建一个正式的PR到<code>nodejieba</code>仓库，添加Windows环境下的替代安装方案（会看得上我这AI一顿乱缝但起码还能跑的东西吗）</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>nodejieba官方仓库：<a class="link"   href="https://github.com/yanyiwu/nodejieba" >https://github.com/yanyiwu/nodejieba<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>@node-rs&#x2F;jieba仓库：<a class="link"   href="https://github.com/napi-rs/jieba" >https://github.com/napi-rs/jieba<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>Node.js官方文档-Native Modules：<a class="link"   href="https://nodejs.org/api/addons.html" >https://nodejs.org/api/addons.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Node.js</tag>
        <tag>Windows</tag>
        <tag>中文分词</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
